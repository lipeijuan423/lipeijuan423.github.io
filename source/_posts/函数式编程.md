---
title: 函数式编程
date: 2019-06-06 22:35:57
tags:
---
### 范畴论
### 函数式编程主要是将复杂的函数符 合成简单的函数

### 特点
  - 函数是一等公民: 拥有和其他数据类型一样的功能:赋值 作为函数 作为返回值
  - 不可改变量 : 函数为变量,不能修改  - 不修改状态
  - 只用表达式,不用语句
  - 没有副作用
  - 引用透明 : 函数运行只靠参数
### 纯函数
- 对于相同的输入，永远会得到相同的输出，而且没有任何可观察的副作用，也不依赖外部环境的状态
- 优点: 降低系统复杂度,可缓存性
> 幂等性: 幂等性是指执行无数次后还具有相同的效果，同一的参数运行一次函数应该与连续两次结果一致。幂等性在函数式编程中与纯度相关，但有不一致
### 偏应用函数,函数的柯里化
- 传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数
- 柯里化: 一种对参数缓存 预加载函数的方法,存储执行一部分参数的新函数
### 函数组合
 - 解决函数嵌套的问题 compose
### point free
- 对象自带的方法转化为纯函数
- 减少不必要命名
### 声明式和命令式
### 惰性求值 惰性函数 惰性链
### 高阶函数
- 一等公民 一个函数为参数 一个函数为返回结果
### 尾调用优化PTC
- 函数调用: 函数内部最后一个动作
- 递归: 函数调用自身 - 大量的调用记录,容易发生栈溢出错误
- 尾调用: 函数最后一行调用其他函数
- 尾递归: 尾调用自身 
> 判断标准: 函数运行最后一步是否调用自身
- 尾递归优化: 将递归变为循环,只需要保存一个调用记录,不会发生栈溢出
```
// 不是尾递归，无法优化 斐波那契数列
function factorial(n) {    // 尾递归
        if (n === 1) return 1;  
        return n * factorial(n - 1);
   }
   function factorial(n, total) { // 尾递归优化
        if (n === 1) return total;  
        return factorial(n - 1, n * total);
    } //ES6强制使用尾递归
```
- 浏览器不支持: 
1. 引擎层面消除递归是一个隐式行为
2. 堆栈信息丢失,难调试

- while 


### 闭包
### 容器 Functor
- 容器: 一种封装
- 函子 functor: 遵守一定特定规则的容器类型 - 留出接口map 操作这个函数
### 错误处理 Either AP
### IO
### Monad